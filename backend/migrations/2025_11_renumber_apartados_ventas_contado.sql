-- Renumber IDs in apartados and ventas_contado consecutively starting at 1
-- and update all related foreign keys atomically.
-- Safe to run in pgAdmin on production (wraps everything in a single transaction).
-- Strongly recommended to backup before running.

BEGIN;

-- 1) Drop FKs that reference apartados or ventas_contado (names unknown â†’ drop dynamically)
DO $$
DECLARE r record;
BEGIN
  FOR r IN (
    SELECT tc.table_schema, tc.table_name, tc.constraint_name
    FROM information_schema.table_constraints tc
    JOIN information_schema.constraint_column_usage ccu
      ON tc.constraint_name = ccu.constraint_name AND tc.table_schema = ccu.table_schema
    WHERE tc.constraint_type = 'FOREIGN KEY'
      AND ccu.table_name IN ('apartados','ventas_contado')
  ) LOOP
    EXECUTE format('ALTER TABLE %I.%I DROP CONSTRAINT %I', r.table_schema, r.table_name, r.constraint_name);
  END LOOP;
END$$;

-- 2) Build stable mapping tables by created_at,id order
DROP TABLE IF EXISTS tmp_map_apartado;
CREATE TEMP TABLE tmp_map_apartado AS
SELECT id AS old_id, ROW_NUMBER() OVER(ORDER BY created_at, id) AS new_id
FROM apartados
ORDER BY created_at, id;

DROP TABLE IF EXISTS tmp_map_contado;
CREATE TEMP TABLE tmp_map_contado AS
SELECT id AS old_id, ROW_NUMBER() OVER(ORDER BY created_at, id) AS new_id
FROM ventas_contado
ORDER BY created_at, id;

-- 3) Update parent IDs
UPDATE apartados a
SET id = m.new_id
FROM tmp_map_apartado m
WHERE a.id = m.old_id;

UPDATE ventas_contado v
SET id = m.new_id
FROM tmp_map_contado m
WHERE v.id = m.old_id;

-- 4) Update child FKs
UPDATE items_apartado ia
SET apartado_id = m.new_id
FROM tmp_map_apartado m
WHERE ia.apartado_id = m.old_id;

UPDATE credit_payments cp
SET apartado_id = m.new_id
FROM tmp_map_apartado m
WHERE cp.apartado_id = m.old_id;

-- status_history tracks entity_type + entity_id (no FK), update for sales only
UPDATE status_history sh
SET entity_id = m.new_id
FROM tmp_map_apartado m
WHERE sh.entity_type = 'sale' AND sh.entity_id = m.old_id;

UPDATE items_venta_contado ivc
SET venta_id = m.new_id
FROM tmp_map_contado m
WHERE ivc.venta_id = m.old_id;

UPDATE payments p
SET venta_contado_id = m.new_id
FROM tmp_map_contado m
WHERE p.venta_contado_id = m.old_id;

-- 5) Re-create FKs
ALTER TABLE items_apartado
  ADD CONSTRAINT items_apartado_apartado_id_fkey
  FOREIGN KEY (apartado_id) REFERENCES apartados(id) ON DELETE CASCADE;

ALTER TABLE credit_payments
  ADD CONSTRAINT credit_payments_apartado_id_fkey
  FOREIGN KEY (apartado_id) REFERENCES apartados(id) ON DELETE CASCADE;

ALTER TABLE items_venta_contado
  ADD CONSTRAINT items_venta_contado_venta_id_fkey
  FOREIGN KEY (venta_id) REFERENCES ventas_contado(id) ON DELETE CASCADE;

ALTER TABLE payments
  ADD CONSTRAINT payments_venta_contado_id_fkey
  FOREIGN KEY (venta_contado_id) REFERENCES ventas_contado(id) ON DELETE CASCADE;

-- 6) Ensure future inserts continue with the next number
-- Add identity if column doesn't already have it, then restart with max+1
DO $$
DECLARE next_apartado bigint;
DECLARE next_contado bigint;
BEGIN
  -- apartados.id
  BEGIN
    EXECUTE 'ALTER TABLE apartados ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY';
  EXCEPTION WHEN others THEN
    -- ignore if already identity/serial
    NULL;
  END;
  SELECT COALESCE(MAX(id),0)+1 INTO next_apartado FROM apartados;
  EXECUTE format('ALTER TABLE apartados ALTER COLUMN id RESTART WITH %s', next_apartado);

  -- ventas_contado.id
  BEGIN
    EXECUTE 'ALTER TABLE ventas_contado ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY';
  EXCEPTION WHEN others THEN
    NULL;
  END;
  SELECT COALESCE(MAX(id),0)+1 INTO next_contado FROM ventas_contado;
  EXECUTE format('ALTER TABLE ventas_contado ALTER COLUMN id RESTART WITH %s', next_contado);
END$$;

COMMIT;

